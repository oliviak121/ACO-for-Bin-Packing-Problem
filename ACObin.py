import random
from numpy.random import choice
import numpy as np 


def initisalise_pheromones_graph(k, b):
    """
    Initialises a construction graph with random pheromone values between 0 and 1
    parameters:
        k (int): the number of items
        b (int): the number of bins
    returns:
        dic: a dictionary representing the construction graph of where 
        each key is and the value is a dictionary of bins and their 
        corresponding pheromone values
    """
    pheromones_graph = {}

    for item in range(1, k +1): #loop over each item
        pheromones_graph[item] = {}
        for bin_num in range(1, b + 1): #loop over each bin for the item
            #initilse each edge with a random pheromone value
            pheromones_graph[item][bin_num] = random.uniform(0, 1)

    return pheromones_graph
        

def construct_ant_path(pheromones_graph, k, b):
    """
    Constructs a path for an ant by selecting a bin for each item based on pheromone levels
    parameters:
        pheromones_graph (dict): the construction graph with the pheromone values for each item-bin edge
        k (int): the number of items
        b (int): the number of bins
    returns:
    list: a path the ant transferses, where each element is the bin for the corresponding item
    """
    path = []

    for item in range (1, k + 1):
        # get pheromone values for current item
        pheromones = pheromones_graph[item]

        # calculate the total sum of all the pheromone paths for this item - normalisation
        total_pheromones = sum(pheromones.values())

        # generate random number between 0 and total pheromone for the threshold
        random_threshold = random.uniform(0, total_pheromones)

        # selecting which bin to go to next
        cumulative_pheromone = 0
        selected_bin = 1
        for bin_num in range (1, b + 1):
            cumulative_pheromone += pheromones[bin_num]
            if cumulative_pheromone >= random_threshold:
                selected_bin = bin_num
                break

        # append the selected bin to the path
        path.append(selected_bin)
    
    return path

def construct_ant_path_generation(pheromones_graph, p, k, b):
    """
    Constructs the paths for a populaiton of ants
    Parameters:
        pheromones_graph (dict): the construction graph with the pheromone values for each item-bin edge
        p (int): the number of ants
        k (int): the number of items
        b (int): the number of bins
    Returns:
        list of lists: a list where each element is a path generated by an ant
    """
    paths = []

    for ants in range(p):
        path = construct_ant_path(pheromones_graph, k, b)
        paths.append(path)

    return paths 


def calculate_fitness(path, k, b, weight_function):
    """
    Calculates the fitness of an ant's path, which is the difference between the resulting heaviest and lightest bins total weight
    Parameters:
        path (list): a path the ant transferses, where each element is the bin for the corresponding item
        k (int): the number of items
        b (int): the number of bins
        weight_function (function): function to calculate the weight of an item
    Returns:
        float: the fitness value, which is the difference between the resulting heaviest and lightest bins total weight
    """
    # itisalise bin weights to zero
    bin_weights = [0] * b

    # distribute the item's weights into the corresponding bins
    for item_index, bin_index in enumerate(path):
        # calculate item weight based on weight function 
        item_weight = weight_function(item_index + 1)
        bin_weights[bin_index - 1] += item_weight #update the weight of the corresponding bin 

    # find fitness
    max_weight = max(bin_weights)
    min_weight = min(bin_weights)
    fitness = max_weight - min_weight

    return fitness

def evaluate_population_fitness(paths, k, b):
    """
    Evaluates the fitness of each ant's path in generation and finds the best-performing path
    Parameters:
        paths (list of lists): a list of paths generated by ants in the generation
        k (int): the number of items
        b (int): the number of bins
    Returns:
        touble: the best path and its corresponding fitness value
    """
    best_fitness = float('inf') #initialised with very high value
    best_path = None

    for path in paths:
        #calculate fitness of path
        fitness = calculate_fitness(path, k, b)

        #if fitness of path is better than best_path then update
        if fitness < best_fitness:
            best_fitness = fitness
            best_path = path 

    return best_path, best_fitness

def pheromone_update(pheromones_graph, paths, fitnesses, b, e):
    """
    Updates the pheromone levels in the construction graph based on the ants paths and their fitness values
    Perameters:
        pheromones_graph (dict): construction graph of pheromones values for each item-bin pair before the update 
        paths (list of lists): a list of paths generated by ants in the generation
        fitness (list of floats): the fitness values corresponding to each path
        b (int): the number of bins 
        e (float): the rate of pheromone evaporation 
    Returns: 
        dict: the updated construction graph with the new pheromone values
    """
    #pheromone evaporation: decreases all pheromone values my multiplying by evaporation rate
    for item in pheromones_graph:
        for bin_num in range(1, b + 1):
            pheromones_graph[item][bin_num] *= e 
    
    #pheromone reinforcement: increase pheromone values based on path fitness
    for path, fitness in zip(paths, fitnesses):
        pheromone_update = 100/max(fitness, 1e-6) #the better the fitness the higher the pheromone deposit, also prevents division by zero

        #update pheromones along the path
        for item_index, bin_index in enumerate(path):
            pheromones_graph[item_index + 1][bin_index] += pheromone_update

    return pheromones_graph

def aco_bin_packing(k, b, p, e, max_evaluations, weight_function):
    """
    The main ACO loop for the Bin Packing Probelem using ACO
    Parameters:
        k (int): the number of items
        b (int): the number of bins
        p (int): the number of ants (paths) per generation
        e (float): the evaporation rate
        max_evaluations (int): the number of fitness evaluations to run ACO algorithm before quiting
    Returns:
        touple: the best, worst, and average fitness values over trial, with total fitness evaluations
    """
    # initialse pheromone graph
    pheromones_graph = initisalise_pheromones_graph(k,b)

    best_overall_path = None
    best_overall_fitness = float('inf')
    worst_overall_fitness = float('-inf')
    total_evaluations = 0 # to track num of fitness evaluations 
    all_generations_data = []

    # main loop for running ACO untill max evaluations is reached
    while total_evaluations < max_evaluations:
        #print(f"Generation {generation + 1}")

        #construct each path for population
        ant_paths = construct_ant_path_generation(pheromones_graph, p, k, b)
        
        #evaluate fitness of each path
        fitnesses = [calculate_fitness(path, k, b, weight_function) for path in ant_paths]
    
        #update total fitness evaluations
        total_evaluations += p

        #find stats for generation
        best_fitness = min(fitnesses)
        worst_fitness = max(fitnesses)
        average_fitness = sum(fitnesses)/p

        #find best path in this generation
        best_path_index = fitnesses.index(best_fitness)
        best_path = ant_paths[best_path_index]

        #update the pheromones based on the fitness
        pheromones_graph = pheromone_update(pheromones_graph, ant_paths, fitnesses, b, e)

        #track the overall best solutions for all generations
        if best_fitness < best_overall_fitness:
            best_overall_fitness = best_fitness
            best_overall_path = best_path

        #track worst overall fitness
        if worst_fitness > worst_overall_fitness:
            worst_overall_fitness = worst_fitness

        #store the generation data 
        all_generations_data.append({
            'total_evaluations': total_evaluations,
            'best_fitness': best_fitness,
            'worst_fitness': worst_fitness,
            'average_fitness': average_fitness
        })

        #print generation stats
        #print(f"  Best fitness in generation {generation + 1}: {best_fitness}")
        #print(f"  Worst fitness in generation {generation + 1}: {worst_fitness}")
        #print(f"  Average fitness in generation {generation + 1}: {average_fitness}")
        #print(f"  Best overall fitness so far: {best_overall_fitness}")

    return best_overall_path, best_overall_fitness, worst_overall_fitness, all_generations_data

def weight_pbb1(i):
    """
    Generates weights of item i for BPP1 - item i has weight i
    Parameters:
        i (int): the item index
    Returns:
        list: the weight of the item
    """
    return i

def weight_pbb2(i):
    """
    Generates weights of item i for BPP2 - item i has weight (i^2)/2
    Parameters:
        i (int): the item index
    Returns:
        list: the weight of the item
    """
    return (i ** 2)/2 


def run_single_trial(k, b, p, e, max_evaluations, seed, weight_function):
    """
    Runs a single trial for a specific ACO configuration with fixed seed
    Parameters:
        k (int): the number of items
        b (int): the number of bins
        p (int): the number of ants
        e (float): the evaporation rate
        max_evaluations (int): the maximum number of fitness evaluations
        seed (int): the random seed to use for reproducibility
        weight_function (function): the function to calculate the item weights
    Returns:
        None 
    """
    # set random seed
    random.seed(seed)

    print(f"\nRunning single trial with p={p}, e={e}, seed={seed}")

    # run the aco algorithm
    best_path, best_fitness, worst_fitness, generations_data = aco_bin_packing(k, b, p, e, max_evaluations, weight_function)

    # output results
    print(f"Best fitness: {best_fitness}")
    print(f"Worst fitness: {worst_fitness}")
    print("Generation data:")
    for gen_data in generations_data:
        print(f"Total Evaluations: {gen_data['total_evaluations']}, Best = {gen_data['best_fitness']}, Worst = {gen_data['worst_fitness']}, Average = {gen_data['average_fitness']}")

def run_multiple_trials(k, b, p, e, max_evaluations, num_trials, weight_function):
    """
    Runs multiple trials (usually will be 5) of the same ACO configuration, using a different seed for each trial
    Parameters:
        k (int): the number of items
        b (int): the number of bins
        p (int): the number of ants
        e (float): the evaporation rate
        max_evaluations (int): the maximum number of fitness evaluations per trial
        num_trials (int): number of trials to run
        weight_function (function): the function to calculate the item weights
    Returns:
        None
    """
    for trial in range(num_trials):
        # generate new random seed for each trial
        trial_seed = random.randint(0, 10000)
        print(f"\nStarting Trial {trial +1} with seed {trial_seed}")
        run_single_trial(k, b, p, e, max_evaluations, trial_seed, weight_function)

def run_all_aco_types(k_bpp1, b_bpp1, k_bpp2, b_bpp2, max_evaluations, num_trials):
    """
    Runs all ACO configurations (4 types) with 5 trials each for BPP1 and BPP2
    Parameters:
        k_bpp1 (int): Number of items for BPP1
        b_bpp1 (int): Number of bins for BPP1
        k_bpp2 (int): Number of items for BPP2
        b_bpp2 (int): Number of bins for BPP2
        max_evaluations (int): The maximum number of fitness evaluations per trial
        num_trials (int): Number of trials to run for each configuration
    Returns:
        None
    """
    # ACO configurations
    aco_configs = [
        (100, 0.90),  # p = 100, e = 0.90
        (100, 0.60),  # p = 100, e = 0.60
        (10, 0.90),   # p = 10, e = 0.90
        (10, 0.60)    # p = 10, e = 0.60
    ]
    
    #run BPP1
    print("\nRunning experiments for BPP1:")
    for p, e in aco_configs:
        print(f"\nRunning ACO with p={p}, e={e}, for BPP1:")
        run_multiple_trials(k_bpp1, b_bpp1, p, e, max_evaluations, num_trials, weight_pbb1)

    #run BPP2
    print("\nRunning experiments for BPP2:")
    for p, e in aco_configs:
        print(f"\nRunning ACO with p={p}, e={e}, for BPP2:")
        run_multiple_trials(k_bpp2, b_bpp2, p, e, max_evaluations, num_trials, weight_pbb2)


#TESTING
##testing single run
k_bpp1 = 500  # Number of items for BPP1
b_bpp1 = 10   # Number of bins for BPP1
k_bpp2 = 500  # Number of items for BPP2
b_bpp2 = 50   # Number of bins for BPP2
max_evaluations = 10000  # Stop after 10,000 fitness evaluations
num_trials = 5  # Run 5 trials

# Run a single trial with p=100, e=0.90 for BPP1
#run_single_trial(k_bpp1, b_bpp1, p=100, e=0.90, max_evaluations=max_evaluations, seed=random.randint(0, 10000), weight_function=weight_pbb1)

##testing multiple runs
run_multiple_trials(k_bpp1, b_bpp1, p=10, e=0.60, max_evaluations=max_evaluations, num_trials=num_trials, weight_function=weight_pbb1)






"""
def run_experiments_bpp(k, b, p_values, e_values, max_generations, weight_function):
    """"""
    Runs experiments for the Bin Packing Problem with different settings
    Parameters:
        k (int): the number of items
        b (int): the number of bins
        p_values (list): list of values for the number of ants (paths) per generation
        e_values (list): List of values for the evaporation rate
        max_generations (int): The number of generations to run the ACO algorithm
        weight_function (function): Function to generate item weights
    Returns:
        None
    """"""
    # Generate weights using the provided weight function (BPP1 or BPP2)
    weights = weight_function(k)

    # Run experiments for each combination of p (ants) and e (evaporation rate)
    for p in p_values:
        for e in e_values:
            print(f"\nRunning experiment with p={p}, e={e}")
            
            # Run the ACO algorithm
            best_path, best_fitness, worst_fitness, generations_data = aco_bin_packing(k, b, p, e, max_generations)
            
            # Output results for this configuration
            print(f"Best fitness: {best_fitness}")
            print(f"Worst fitness: {worst_fitness}")
            print("Generation data:")
            for gen_data in generations_data:
                print(f"Generation {gen_data['generation']}: Best = {gen_data['best_fitness']}, Worst = {gen_data['worst_fitness']}, Average = {gen_data['average_fitness']}")

"""


"""
# Parameters for BPP1 and BPP2 experiments
k_bpp1 = 500  # Number of items for BPP1
b_bpp1 = 10   # Number of bins for BPP1
k_bpp2 = 500  # Number of items for BPP2
b_bpp2 = 50   # Number of bins for BPP2

# Parameter values for ants and evaporation rate (from coursework)
p_values = [100, 10]  # Number of ants
e_values = [0.9, 0.6]  # Evaporation rates

max_generations = 100  # Number of generations

# Run experiments for BPP1
#print("\nRunning experiments for BPP1:")
#run_experiments_bpp(k_bpp1, b_bpp1, p_values, e_values, max_generations, generate_bpp1_weights)

# Run experiments for BPP2
print("\nRunning experiments for BPP2:")
run_experiments_bpp(k_bpp2, b_bpp2, p_values, e_values, max_generations, generate_bpp2_weights)
"""



"""
# Example usage
k = 500  # Number of items
b = 10   # Number of bins
p = 100  # Number of ants per generation
e = 0.9  # Evaporation rate
max_generations = 50  # Number of generations

# Run the ACO algorithm
best_path, best_fitness, worst_fitness, generations_data = aco_bin_packing(k, b, p, e, max_generations)

print("\nBest path found:", best_path)
print("Best fitness found:", best_fitness)
print("Worst fitness found:", worst_fitness)

# Optionally, you can print or analyze the data for each generation
for gen_data in generations_data:
    print(f"Generation {gen_data['generation']}: Best = {gen_data['best_fitness']}, Worst = {gen_data['worst_fitness']}, Average = {gen_data['average_fitness']}")
"""


